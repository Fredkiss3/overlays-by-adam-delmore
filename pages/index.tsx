import type { NextPage } from "next"
import Head from "next/head"
import React, { useCallback, useEffect } from "react"
import { useEvent, useQueue } from "../hooks"
import type {
  TwitchChannelFollowEvent,
  TwitchChannelRedemptionEvent,
  TwitchChannelSubscribeEvent,
  TwitchEvent,
} from "../lib/twitch"
import { Notification } from "../components"
import { useRouter } from "next/router"
import { getReward, Scene } from "../lib/rewards"
import OBSWebSocket from "obs-websocket-js"

const obs = new OBSWebSocket()

const Home: NextPage = () => {
  const router = useRouter()
  const [scene, setScene] = React.useState<Scene>()
  const [, setNotifications, activeNotification] = useQueue<
    TwitchChannelFollowEvent | TwitchChannelSubscribeEvent
  >()
  const [, setSnapFilters, activeSnapFilter] =
    useQueue<TwitchChannelRedemptionEvent>(5 * 60 * 1000)
  const [, setRedemptions, activeRedemption] =
    useQueue<TwitchChannelRedemptionEvent>()

  const setObsScene = async (scene: Scene) => {
    await obs.send("SetCurrentScene", {
      "scene-name": scene,
    })
  }

  const switchScene = useCallback(async (to: Scene) => {
    const camera1 = "BA868701-8131-49CB-8EDD-8C7E6E7CD60B"
    const camera2 = "14029354-EC7B-4409-B4BC-708E88D9D782"
    const url = (layer: string, action: string) =>
      `http://adams-mac-mini.local:8989/api/v1/documents/691811177/layers/${layer}/${action}`

    switch (to) {
      case "Camera":
      case "Camera (HD)":
        await fetch(url(camera1, "setLive"))
        await fetch(url(camera2, "setOff"))
        await setObsScene(to)
        break

      case "Screen":
        await fetch(url(camera2, "setLive"))
        await fetch(url(camera1, "setOff"))
        await setObsScene("Screen")
        break

      default:
        break
    }
  }, [])

  const handleTwitchEvent = (event: TwitchEvent) => {
    if (event.type === "channel.follow" || event.type === "channel.subscribe") {
      setNotifications((notifications) => [...notifications, event])
    }
    if (event.type === "channel.channel_points_custom_reward_redemption.add") {
      const reward = getReward(event.event.reward.id)
      if (reward?.type === "snap-filter") {
        setSnapFilters((redemptions) => [...redemptions, event])
      } else {
        setRedemptions((redemptions) => [...redemptions, event])
      }
    }
  }

  useEvent<TwitchEvent>("twitch-event", (e) =>
    handleTwitchEvent({ ...e, type: e.subscription.type } as TwitchEvent)
  )

  useEffect(() => {
    const rewardId = activeRedemption?.event.reward.id
    const reward = getReward(rewardId)

    if (reward?.type === "shell") {
      fetch("/api/shell", {
        method: "post",
        body: JSON.stringify({ rewardId }),
      })
    }

    if (reward?.scene) switchScene(reward.scene)
  }, [activeRedemption, switchScene])

  useEffect(() => {
    const rewardId = activeSnapFilter?.event.reward.id
    const reward = getReward(rewardId)

    // If there's no active redemption, we need to toggle the snap filter off
    fetch("/api/snap", {
      method: "post",
      body: JSON.stringify({ rewardId }),
    })

    if (reward?.scene) {
      switchScene(reward.scene)
    }
  }, [activeSnapFilter, switchScene])

  useEffect(() => {
    if (scene === "Camera" && !activeSnapFilter) {
      switchScene("Camera (HD)")
    } else if (scene === "Camera (HD)" && activeSnapFilter) {
      switchScene("Camera")
    }
  }, [activeSnapFilter, scene, switchScene])

  useEffect(() => {
    const timer = setInterval(() => {
      fetch(`/api/ping?id=${router.query.id}`, {
        method: "post",
      })
    }, 1000 * 5)
    return () => clearInterval(timer)
  }, [router.query.id])

  useEffect(() => {
    async function init() {
      obs.on("SwitchScenes", (data) => {
        setScene(data["scene-name"] as Scene)
      })

      // You must add this handler to avoid uncaught exceptions.
      obs.on("error", (err) => {
        console.error("socket error:", err)
      })

      try {
        await obs.connect({ address: "127.0.0.1:4444" })
        const scenes = await obs.send("GetSceneList")
        setScene(scenes["current-scene"] as Scene)
      } catch (error) {
        console.log(error)
      }
    }

    init()

    return () => {
      obs.disconnect()
    }
  }, [])

  return (
    <div className="relative flex flex-col h-[1080px] w-[1920px] space-y-10">
      <Head>
        <title>Adam&apos;s Twitch Overlay</title>
        <meta name="description" content="Generated by create next app" />
        <link rel="icon" href="/favicon.ico" />
      </Head>
      {activeNotification && (
        <Notification>
          {contentFromTwitchEvent(activeNotification)}
        </Notification>
      )}
    </div>
  )
}

export default Home

function contentFromTwitchEvent(event: TwitchEvent) {
  switch (event.subscription.type) {
    case "channel.follow":
      return `${event.event.user_name} followed!`
    case "channel.subscribe":
      return `${event.event.user_name} subscribed!`

    default:
      break
  }
}
